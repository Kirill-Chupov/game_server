# Многопользовательский игровой сервер
## Описание проекта:
Сервер для многопользовательской игры, в которой игроки управляют собаками-ищейками, собирают потерянные предметы на карте (лут) и возвращают их в бюро находок (офис).

В рамках разработки проекта реализован Backend, а Frontend был предоставлен командой [Яндекс Практикум](https://practicum.yandex.ru/).

В проекте введено разделение для доступа к статическим файлам (дороги, здания, офисы и прочие модели) и к API.

Статические файлы можно получить асинхронно без ограничений, т.к. объекты не изменяются в процессе игры и гонка данных в данной секции отсутствует.

Доступ к API организован с помощью **boost::asio::strand** для сохранения консистентного состояния игры. На данный момент реализован один strand на все игровые сессии.

Для чтения параметров командной строки использован **boost::program_options**. 
### Поддерживаются следующие опции:
```bash
Allowed options:
  -h [ --help ]                     produce help message
  -t [ --tick-period ] milliseconds set tick period
  -c [ --config-file ] file         set config file path
  -w [ --www-root ] dir             set static files root
  --randomize-spawn-points          spawn dogs at random positions
  --state-file file                 set state file path
  --save-state-period milliseconds  set save state period
```
#### Обязательные параметры:
- **--config-file** - путь к файлу конфигурации.
- **--www-root** - путь к статическим файлам.
#### Опциональные параметры:
- **--tick-period** - задаёт интервал обновления игрового состояния в миллисекундах. При отсутствии параметра время изменяется только через запрос к API. Если параметр задан, запрос к API всегда будет возвращать ошибку 400, т.к. время должно изменяться только из одного источника.
- **--randomize-spawn-points** - если параметр отсутствует, лут и игроки всегда появляются в начале первой дороги, иначе лут и игроки появляются в случайном месте.
- **--state-file** - задаёт путь к файлу сохранения состояния игры, может быть задан без параметра `--save-state-period`, в таком случае сохранение будет производиться только при остановке сервера.
- **--save-state-period** - задаёт период автосохранения, при этом не отменяет сохранение при выходе из игры. Не может быть использован без `--state-file`.

## Ключевые особенности:
- Асинхронный HTTP сервер на базе Boost.Beast.
- Поддержка нескольких карт и игровых сессий - каждая карта работает внутри своей сессии.
- Генерация лута - вероятностная модель, зависящая от числа игроков, предметов, находящихся на карте, и прошедшего времени.
- Детектор коллизий - автоматическое обнаружение подбора предметов и взаимодействия с офисами. Коллизии с границами дорог выполнены по упрощённому алгоритму, для каждой дороги при её инициализации через проекцию на оси вычислены допустимые значения x и y. Это ускоряет поиск коллизий с границами дороги, т.к. расчёты выполнены при инициализации.
- Аутентификация по токенам - каждый игрок получает уникальный токен.
- Автоматическое удаление бездействующих игроков - при превышении лимита простоя игрок покидает игру, его токен удаляется, а счёт сохраняется в PostgreSQL.
- Сохранение и восстановление состояния - полный снимок игры: токены, позиции игроков и лута для каждой сессии. Статические объекты не сохраняются, они инициализируются как обычно из файла конфигурации, для оптимизации размера файла сохранения.
- Логирование - все события и запросы логируются в JSON-формате и передаются в поток `std::cout`. Для сохранения в файл перенаправьте поток в файл.
- Docker Compose - готовый сценарий для запуска сервера вместе с PostgreSQL.

## Архитектура и использованные паттерны:
Проект разделён на логические модули, что обеспечивает слабую связность и лёгкость расширения
| Модуль             | Назначение                                                                                                                                    |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| model              | Ядро игры: карты, сессии, собаки, лут, дороги, здания, офисы. Содержит игровую логику, перемещение, коллизии, генерацию лута.                 |
| app                | Прикладной слой: управление игроками, токенами, взаимодействие с БД.                                                                          |
| request_handler    | Обработка HTTP-запросов: `ApiHandler` для REST API, `StaticHandler` для статики, `LoggingRequestHandler` - декоратор над `RequestHandler`.    |
| http_server        | Обёртка над Boost.Beast: асинхронная обработка соединений с таймаутами.                                                                       |
| postgres           | Работа с PostgreSQL: репозитории, `UnitOfWork`, фабрика `UOW`. Обеспечивает транзакционное сохранение рекордов.                               |
| state              | Сериализация состояния игры и приложения (классы-представители `Representation` для Boost.Serialization).                                     |
| collision_detector | Алгоритмы обнаружения столкновений и подбора предметов.                                                                                       |
| loot_generator     | Вероятностный генератор новых предметов.                                                                                                      |
| common             | Утилиты: tagged-типы, логгер, парсер командной строки, тикер, DTO (Data Transfer Object). Общие сущности, не привязанные к определённому слою. |

### Применённые паттерны проектирования:
- **Декоратор** - `LoggingRequestHandler` оборачивает `RequestHandler`, добавляя логирование входящих запросов и исходящих ответов.
- **Наблюдатель** - Boost.Signals2 используется для двух целей:
  - `Game::tick_signal_` уведомляет подписчиков (например, `AutoSaver`) о каждом тике.
  - `GameSession::exit_signal_` уведомляет `Application` о выходе игрока по таймауту.
- **Репозиторий** - `ScoresRepository` абстрагирует работу с таблицей рекордов.
- **Единица работы (Unit of Work)** - интерфейсы `UnitOfWork` и `UnitOfWorkFactory` инкапсулируют транзакции при записи результатов в БД.
- **Адаптер** - `collision_detector_adapter` преобразует объекты игры (собаки, лут, офисы) в формат, понятный детектору коллизий.
- **Фабрика** - `UnitOfWorkFactory` создаёт экземпляры `UnitOfWork`.

## HTTP API
| Метод | Эндпоинт                     | Описание                                                             | Аутентификация |
|-------|------------------------------|----------------------------------------------------------------------|----------------|
| GET   | `/api/v1/maps`               | Список карт (id, name)                                               | нет            |
| GET   | `/api/v1/maps/{id}`          | Детальная информация о карте                                         | нет            |
| GET   | `/api/v1/game/records`       | Таблица рекордов                                                     | нет            |
| GET   | `/api/v1/game/state`         | Состояние игры                                                       | да             |
| GET   | `/api/v1/game/players`       | Список игроков в сессии                                              | да             |
| POST  | `/api/v1/game/player/action` | Управление игровым персонажем                                        | да             |
| POST  | `/api/v1/game/tick`          | Управление временем в тестах (при обычном запуске метод недоступен) | нет            |
| POST  | `/api/v1/game/join`          | Подключение игрока к игре                                            | нет            |

## Сборка и зависимости:
### Требования (запуск без использования Docker-образа):
- **Conan** - версии 1.x (для работы с 2.x потребуется изменить `conanfile`).
- **PostgreSQL** - без установленной переменной окружения `GAME_DB_URL` запуск приложения будет остановлен (исключение `std::runtime_error`).
### Зависимости (управляются через Conan):
- Boost 1.78.0 (компоненты: system, filesystem, asio, beast, json, log, serialization, signals2, program_options).
- libpqxx 7.7.4.
- Catch2 3.7.1 (для тестов).
## Запуск приложения:
### Docker compose:
Рекомендуется использовать `docker compose` для запуска приложения - внешние зависимости установятся автоматически в Docker-контейнере.

Стандартный запуск:
```bash
docker compose up --build
```

Запуск в фоновом режиме:
```bash
docker compose up --build -d
```

Для остановки контейнеров:
- Если запуск был без флага `-d`, нажмите `Ctrl+C`.
- Если контейнеры работают в фоне, выполните:
```bash
docker compose down
```
### Локальный запуск:
Работоспособность приложения проверялась только на Ubuntu, с запуском на Windows могут быть проблемы. Для запуска на Windows рекомендую воспользоваться Docker.

Выполните из корневой директории следующие команды:
```bash
# Сборка
mkdir build && cd build
conan install .. --build=missing -s build_type=Release -s compiler.libcxx=libstdc++11
cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_TESTS=off
cmake --build . --parallel
cd ..

# Запуск
export GAME_DB_URL="postgres://postgres:pass@localhost:5432/postgres"
./build/bin/game_server -c data/config.json -w static/ -t 10 --randomize-spawn-points
```


После сборки и запуска, откройте в браузере адрес `http://127.0.0.1:8080/` (`http://localhost:8080/`) и наслаждайтесь игрой.

Для остановки приложения передайте сигнал `SIGINT` или `SIGTERM` (например, `Ctrl+C` в терминале).

## Заключение:
Проект представляет собой клиент-серверное приложение (игровой сервер), демонстрирующее современные подходы к разработке на С++: асинхронное сетевое взаимодействие, многопоточность, работу с данными, сериализацию игрового состояния и применение паттернов проектирования. Сервер готов к развёртыванию и может служить основой для создания собственных игровых проектов.